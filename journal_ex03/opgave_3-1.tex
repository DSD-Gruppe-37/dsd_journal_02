\subsection{Signed and Unsigned Arithmetic}

% Intro 
\subsubsection{Introduktion}

Ved at udnytte VHDLs indbyggede arithmetiske funktioner, har vi mulighed for at simplificere four-bit-adderen fra øvelse 2 (Ø2).
Dette vil ske vha.  \textit{casting} fra \texttt{std\_logic\_vector} til \texttt{unsigned} / \texttt{signed}. 

Vi har i denne opgave, skrevet og testet 3 four-bit-adders: signed, unsigned og unsigned w. carry, 

% Design
\subsubsection{Design og implementering}

Vi brugte i Ø2 \texttt{std\_logic\_vector} som input og output - dette vil ske igen. 

Dog bliver både signalet der behandles, midlertidigt lavet om til enten \texttt{signed} eller \texttt{unsigned}.

Dette giver mulighed for at bruge regneoperatorer på en ny måde - der kan adderes, trækkes fra, multipliceres og divideres. Den fulde entity, med de tilhørende architectures ses i \srcref{ex03/vhdl/fourbitaddersimple.vhd}, det hele er samlet i én fil.

\dsdsrc{ex03/vhdl/fourbitaddersimple.vhd}{Entity dekleration, der går igen i de 3 adders og Four-bit-adder: architecture: unsigned with carry}{0}{32}

\dsdsrc{ex03/vhdl/fourbitaddersimple.vhd}{Four-bit-adder: architecture: unsigned\_impl}{34}{47}

\dsdsrc{ex03/vhdl/fourbitaddersimple.vhd}{Four-bit-adder: architecture: signed\_impl}{48}{60}

% Results
\subsubsection{Resultater}

\dsdfig{ex3-1_fulladdersRTL}{9cm}{(a) signed  full adder, (b) unsigned full adder}

\dsdfig{ex3-1_unsignedcarryRTL}{9cm}{RTL view af en unsigned full adder med carry  }

\dsdfig{ex3-1_unsignedtechmap}{9cm}{Technology map view af unsigned full adder med carry - inkl. udsnit af de interne blokkes arbejde.}

Ved sammenligning RTL-views ses det funktionaliteten i de adders er ens, dette vises på \figref{ex3-1_fulladdersRTL} og ses på technology map viewet i \figref{ex3-1_unsignedsignedpostmap}



\dsdfig{ex3-1_unsignedsignedpostmap}{9cm}{Udsnit af technology map view  af en signed og unsigned adder. Der er ingen forskel i praksis.}



%//TODO Indsæt billeder af adders på DE-2 BOARD
\dsdfig{ex3-1_unsignedtiming}{9cm}{Udsnit af timingsimuleringeringen der viser funktionaliten for adderen med carry.}

For at teste de to adders laves følgende test:

\dsdtab{
\begin{tabular}{p{3cm}p{3cm}p{3cm}}\toprule
 Input & Forventet output & Reelt output \\\midrule
\texttt{A: 0b0110+\newline B: 0b0010\phantom{+}} & 
\texttt{S: 0b1010\newline U: 0b1010} & 
\texttt{S: 0b1010\newline U: 0b1010}
\end{tabular}
}{Testsetup til signed og unsigned four-bit-adders.}{signedunsigedtest}


% Discussion
\subsubsection{Diskussion}

Ved den funktionelle timingsimulering fremkom en række uforklarlige outputs, se \figref{strangeTimingSignedUnsignedFunctional} .

\dsdfig{ex3-1_strangeTimingSignedUnsignedFunctional}{9cm}{Timing issues fra signed og unsigned Adder.}

% Conclusion
\subsubsection{Konklusion}

Ved at bruge \texttt{ieee.numeric\_std}, kan man vha. meget få operationer, skrive relativt komplekse funktioner via dataflowstilarten.

Desuden pakkes flere implementationsmuligheder nemt ind i en enkelt entity.

%//TODO Hvorfor er det smart med flere architectures i en entitiy?

